大数据学习笔记(2021-12-02版)
一、Linux基础(持续更新中…)
1. 基础命令
查看命令的帮助文档: 命令 –help 或 man 命令
例如: ll –-help   man ls
1.1  pwd 列出当前目录的路径
1.2  ls 列出当前目录下的所有文件
1.3  ll 列出当前目录下的文件(包含文件信息)
      ll  -a 列出当前目录下的所有文件(包含隐藏文件) 
1.4  touch      创建空文件
1.5  mkdir      创建目录
mkdir -p  递归创建目录
1.6  mv  重命名文件/目录  移动或剪切文件/目录
1.7  ln  链接文件
1.8  cd  切换目录
      cd ..  cd /   cd ~
1.9  rm  删除文件/目录  
      rm  -rf  强制递归删除所有文件和目录 (慎重!)
1.10 cp  复制/粘贴文件    
cp -r 复制目录
1.11 scp -rp  xxx  用户名@ip或hostname: xxx
远程复制 
1.12 文件属性
-rw-r—r--. 权限
-  文件
d  目录
l  链接
r  读
w  写
x  执行
3  目录或链接个数
root   所属用户
root   所属组
1234   文件大小(字节)
Mar 28 20:59   最后修改时间
Hello.txt   文件/目录名
1.13 chmod   分配权限
chmod u+x 文件名   给当前所有者添加执行权限
chmod 777 文件名   添加rwxrwxrwx
1.14 cat 文本内容查看
cat -b 显示行号输出
more / less  分屏显示(现实更多/更少)  q 退出显示模式


1.15 压缩或解压
tar.gz包
压缩: tar -zcvf  压缩包名  压缩文件或目录
解压: tar -zxvf  压缩包名
zip包
压缩: zip -r 压缩包名  压缩文件或目录
解压: unzip  压缩包名
1.16 输出及显示
echo  “hello,world!”
echo $PATH
echo $JAVA_HOME
1.17 软件安装和卸载
a. 压缩包安装方式: 直接下载,解压,配置相应环境变量即可
b. 在线安装: yum  install -y  xxx
显示包信息: yum info
更新包: yum update 
列出已安装或可安装的包: yum list 
删除程序: yum  remove xxx 
清理缓存: yum clean all



1.17 查看操作历史
history  默认可以保留1000
history N 显示最近N条命令
history -c 清除所有的历史记录
history -w 文件名 保存历史记录到文件中
1.18 磁盘和内存使用情况
df -h 磁盘使用情况
free -h 内存使用情况
1.19 清屏
clear
CTR+L
1.20 关机和重启
shutdown 关机
reboot  重启
exit 退出当前登录状态







2. 进阶命令
2.1 vi/vim编辑器
进入编辑模式: i
退出不保存: :q!
退出保存: :wq 或 :x
查找字符串: /  ->  需要查找的字符串 -> 回车
查找某一行内容: : set nu -> : 1
复制粘贴: 光标移动到希望复制的那一行内容上,按yy
然后按p,把刚才复制内容粘贴到下一行,按一次p粘贴一行,
一直按到你喊停为止,输入:wq保存即可
快速删除: 将光标定位到想要删除的那一行内容上面,连按dd,即可删除当前行的内容;如果想要删除当前行下的所有内容,先连按999,然后再连按dd即可
快速跳到文件首行和末行: 命令模式下,通过G可以快速将光标移动到最后一行,如果还要再回退到第一行,只需要按dd即可快速跳转到第一行
修改文件到一半没有正常关闭,再次打开问题: 
ll -a  删除.swp文件即可
2.2 文件内容统计相关命令
a. wc  统计字数相关信息
wc -m  获取字符数量
wc -l 获取行数
wc -L 获取最长一行内容的长度
wc -w 文件中单词个数,默认使用空白符分隔
b. sort 对数据进行排序
sort -n 按照数据的数值大小排序
sort -rn 倒序排序
sort -k 2 -n 文件名 按照某一列中的数字进行排序
c. uniq 检查重复的行列
uniq –c 去重并输出重复次数
uniq -u  输出不重复的行
d. head 取前N条数据
head -3 文件名
2.3  日期相关
date 获取系统当前时间
date + “%Y-%m-%d %H:%M:%S” 对日期进行格式化输出
date +%s ”2026-01-01 00:00:00”  获取时间戳
date –-date=“2026-01-01 00:00:00” 指定时间
date –date=“1 days ago” 获取昨天日期
date –date=“1 days ago”+%Y-%m-%d 获取昨天日期并格式化



2.4 进程相关
ps 显示进程信息
ps -ef
ps -ef | grep java
netstat 显示端口信息
netstat -anp 
netstat -anp | grep 22
jps 显示Java进程信息
top或htop 动态监控进程信息
kill PID  杀死进程   kill -9 PID 强制杀死进程
2.5 Linux三剑客(grep sed awk)
a. grep 查找文件里符合条件的字符串(支持正则匹配)
grep ^a 文件名  查询文件中以字母a开头的内容
grep -i ABC 文件名   -i忽略大小写
grep –I ABC -n 文件名  -n定位字符串所在位置
ps -ef | grep java
ps -ef | grep java | grep -v grep  -v为过滤
b. sed 文本编辑
增加数据操作: 
sed ‘1a\haha’ hello.txt 
追加haha到第一行下面 (行号是从1开始的)

sed ‘1i\haha’ hello.txt 
插入haha到第一行
sed ‘$i\haha’ hello.txt
插入haha到最后一行
删除数据操作:
sed ‘7d’ hello.txt 
删除第7行内容
Sed ‘$d’ hello.txx
删除最后一行
替换数据操作:
sed [address]s/pattern/replacement/flags
address 可选项 指定要操作的具体行
s 替换操作
pattern 需要替换的内容
replacement 要替换的新内容
flags 
1-512之间的任意一个数字,表示指定要替换的字符串
在这一行中出现第几次时才进行替换;
g 对每一行数据中所有匹配到的内容全部进行替换,如果flags位置的值为空,则只会在第一次匹配成功时做替换操作
sed ‘s/l/a/1’ hello.txt
sed ‘2s/l/a/1’ hello.txt
sed -i ‘2s/l/a/g’ hello.txt      -i 修改源文件
c. awk 文本分析
awk [option] program file
option 一般指定文本分隔符
program 具体处理逻辑
awk在处理文本数据时,会自动给每行中的每个字段分配一个变量,变量从1开始,例如$1表示文本中的第一个数据字段,$0代表整个文本行的内容
awk ‘{print $1}’ hello.txt
awk -F: ‘{print $1}’ /etc/passwd 
-F指定字段分隔符
awk ‘/world/ {print $0}’ hello.txt 
对每次读取到的那一行数据进行匹配
Awk ‘($1 ~/world/) {print $1}’ hello.txt
对某一列数据进行匹配
Awk ‘($1 !~/world/) {print $1}’ hello.txt
对某一列数据进行匹配





2.6 Linux基本配置
a. ip映射和hostname
查看ip地址信息: ip addr
ip映射配置:
vim /etc/hosts
192.168.0.200  master
192.168.0.201  slave-1
192.168.0.202  slave-2
192.168.1.107  bruce-mbp
hostname配置:
vim /etc/hostname
master










b. 网络配置
vim /etc/sysconfig/network-scripts/ifcfg-ens33
TYPE="Ethernet"
PROXY_METHOD="none"
BROWSER_ONLY="no"
BOOTPROTO="static"
DEFROUTE="yes"
IPV4_FAILURE_FATAL="no"
IPV6INIT="yes"
IPV6_AUTOCONF="yes"
IPV6_DEFROUTE="yes"
IPV6_FAILURE_FATAL="no"
IPV6_ADDR_GEN_MODE="stable-privacy"
NAME="ens33"
UUID="9a0df9ec-a85f-40bd-9362-ebe134b7a100"
DEVICE="ens33"
ONBOOT="yes"
IPADDR=192.168.182.100
GATEWAY=192.168.182.2
DNS1=192.168.182.2
网络连接: NAT模式/桥接模式

vim /etc/resolv.conf
nameserver 192.168.0.1
service network restart
ping 192.168.0.200 ping本服务器
ping www.baidu.com ping外网
ping 192.168.1.107 ping宿主机
c. 防火墙和SELINUX
防火墙:
systemctl stop firewalld 关闭防火墙
systemctl start firewalld  启动防火墙
systemctl disable firewalld 禁用防火墙
systemctl enable firewalld 开机启动防火墙
systemctl status firewalld 查看防火墙状态
systemctl restart firewalld 重启防火墙
SELINUX:
vi /etc/selinux/config
强制模式SELINUX=enforcing：表示所有违反安全策略的行为都将被禁止
宽容模式SELINUX=permissive：表示所有违反安全策略的行为不被禁止，但是会在日志中作记录
禁用模式SELINUX=disabled 

d. 启停系统服务
systemct start 服务名称  启动服务
systemct stop 服务名称   停止服务
systemct restart 服务名称 重启服务
systemct enable 服务名称 设置服务开启启动
systemct diable 服务名称 禁用服务
systemct status 服务名称 查看服务状态
service 服务名称 start  启动服务
service 服务名称 stop  停止服务
service 服务名称 restart  重启服务
service 服务名称 status 查看服务状态
e. ssh免密码登录
systemctl enable sshd.service
systemctl restart sshd.service
systemctl status sshd.service
ssh-keygen -t rsa
ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.0.101
cat id_rsa.pub >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys
ssh root@192.168.0.200
ssh root@master
f. yum源配置
强制卸载所有包: rpm -qa|grep yum|xargs rpm -e –nodeps
查看是否卸载完全: rpm -qa|grep yum 
下载相关的rpm插件
wget https://mirrors.aliyun.com/centos/7/
os/x86_64/Packages/python-chardet-2.2.1-3.el7.noarch.rpm 
wget https://mirrors.aliyun.com/centos/7/
os/x86_64/Packages/python-kitchen-1.1.1-5.el7.noarch.rpm 
wget https://mirrors.aliyun.com/centos/7/
os/x86_64/Packages/python-urlgrabber-3.10-10.el7.noarch.rpm 
wget https://mirrors.aliyun.com/centos/7/
os/x86_64/Packages/rpm-4.11.3-45.el7.x86_64.rpm 
wget https://mirrors.aliyun.com/centos/7/
os/x86_64/Packages/rpm-build-libs-4.11.3-45.el7.x86_64.rpm 
wget https://mirrors.aliyun.com/centos/7/
os/x86_64/Packages/rpm-python-4.11.3-45.el7.x86_64.rpm 
wget https://mirrors.aliyun.com/centos/7/
os/x86_64/Packages/wget-1.14-18.el7_6.1.x86_64.rpm 
wget https://mirrors.aliyun.com/centos/7/
os/x86_64/Packages/yum-3.4.3-168.el7.centos.noarch.rpm 
wget https://mirrors.aliyun.com/centos/7/
os/x86_64/Packages/yum-metadata-parser-1.1.4-10.el7.x86_64.rpm 
wget https://mirrors.aliyun.com/centos/7/
os/x86_64/Packages/yum-plugin-filter-data-1.1.31-54.el7_8.noarch.rpm 
wget https://mirrors.aliyun.com/centos/7/
os/x86_64/Packages/yum-updateonboot-1.1.31-54.el7_8.noarch.rpm 
wget https://mirrors.aliyun.com/centos/7/
os/x86_64/Packages/yum-utils-1.1.31-54.el7_8.noarch.rpm 
安装所有插件: rpm -ivh *.rpm --force --nodeps 
修改yum配置: wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 
修改CentOS-Base.repo文件:
vim /etc/yum.repos.d/CentOS-Base.repo  # 把$releasever全局替换成7执行 :%s/$releasever/7/g  # mirrors.aliyuncs.com 全部改成 mirrors.aliyun.com # 不然后面会报错,mirrors.aliyuncs.com这个域名好像有问题,具体情况不明 :%s/aliyuncs/aliyun/g :wq  保存退出 
清理yum源: yum clean all 
生成元数据缓存: yum makecache    
测试: yum -y install tree  
g.安装部署大数据环境(详见说明大数据平台安装部署文档)
基础环境:
Java、Python、Nodejs、MySQL、Maven、Scala
Hadoop、Hive、Azkaban、Datax、Spark
大数据组件:
Flume、Kafka、HBase、Flink、Phoenix
Zookeeper、Kylin、Druid、Presto/Trino、Drill
Redis、ClickHouse、Canal、Elasticsearch、Logstash、Kibana、HUE、SuperSet、Ranger、Atlas
Hudi、Airflow、海豚调度、Impala、Kudu、Alluxio等

二、Shell脚本编程(持续更新中…)
1. 什么是Shell
Shell就是用户与Linux系统沟通的一个桥梁,我们操作命令的命令行即为Shell
Shell编程就是把之前在shell中执行的单个命令按照一定的逻辑和规则,组装到一个文件中,后面执行时可以直接执行这个文件即可,这个文件就是Shell脚本,Shell编程最终其实就是要开发一个Shell脚本
2. Shell脚本规范
2.1 约定俗称文件以.sh结尾
2.2 第一行内容固定为: #!/bin/bash
可以理解为一个导包语句,将Shell的执行环境引入进去,这里的#号不是注释
vim  hello.sh
#!/bin/bash
echo hello world!
2.3 执行Shell脚本
chmod u+x hello.sh
bash hello.sh
sh  hello.sh
sh -x hello.sh
./hello.sh
3. Shell中的变量
3.1 变量命名规范和打印变量值
a. Shell中的变量不需要声明,初始化也不需要指定类型
b. 只能使用数字、字母和下划线,且不能以数字开头
c. 变量赋值是通过”=”进行赋值,在变量、等号和值之间不能
出现空格
d. 打印变量的值: 
echo $name    echo $name hehe
echo ${name}  echo $namehehe
如果想在变量结果后面直接无缝拼接其他字符串,
只能使用带{}的形式;如果带空格就无所谓了
3.2 变量的分类
a. 本地变量
VAR_NAME=VALUE
一般用于在Shell脚本中定义一些临时变量,只对当前Shell
进程有效,对当前进程的子进程和其他Shell进程无效
一句话:Shell中本地变量的特性,注意本地变量的生效范围,
只对当前Shell脚本中有效
b. 环境变量
export VAR_NAME=VALUE
生效范围: 对当前进程和其子进程有效,对其他进程无效

实际工作中,我们需要设置环境变量都是需要让它永久有效:
只需要把这个临时的设置添加到指定配置文件中,以后每次开启
Shell进程时,都会去加载那个指定的配置文件中的命令,就可以实现永久生效
/etc/profile  保证对所有用户都生效
source /etc/profile  立即生效
~/.bash_profile 保证对当前用户生效
source /etc/profile  立即生效
c. 位置变量
在进行Shell编程时,有时候我们想给Shell脚本动态传递一些参数,这时需要用到位置变量,类似$0
格式: location.sh abc xyz
d. 特殊变量
$? 它表示上一条命令的返回状态码,状态码在0~255之间
执行成功为0,执行失败为1-22之间数字
应用场景: 工作中,我们有时会根据上一条命令执行结果来执行后面不同的业务逻辑
0 命令执行成功   1 通用未知错误 2 误用Shell命令
126 命令不可执行 127 没找到命令 128 无效推出参数
128+x Linux信号x的严重错误 
130 命令通过Ctrl+C控制码越界  255 退出码越界
$# 它表示Shell脚本所有参数的个数
3.3 变量和引号的特殊使用
‘’ 单引号不解析变量  name=jack  echo ‘$name’
“” 双引号解析变量    name=jack  echo “$name”
`` 反引号 执行并引用命令的执行结果 
name=pwd echo `$name`
name=pwd echo $($name)
echo “’$name’”
4. Shell中的循环和判断
4.1 for循环
a.第一种格式: 适合用在迭代多次,步长一致的情况
for((i=0;i<10;i++))
do
循环体
done
vim for1.sh
#!/bin/bash
for((i=0;i<10;i++))
do
echo $i
done


b. 第二种格式: 针对没有规律的列表或者有限的几种情况
进行迭代
for i in 1 2 3
do
循环体
done
for((i=0;i<10;i++))
do
循环体
done
vim for2.sh
#!/bin/bash
for i in 1 2 3
do
echo $i
done
4.2 while循环: 用于循环次数未知或不便于使用
for直接生成较大列表时
while 测试条件
do
循环体
done
测试条件定义: test EXPR 或 [ EXPR ]
整型: -gt(大于)  -lt(小于)  -ge(大于等于)
       -le(小于等于) -eq(等于) -ne(不等于)
字符串: =(等于) !=(不等于)
vim while1.sh
#!/bin/bash
while test 2 -gt 1
do
echo yes
sleep 1
done
vim while2.sh
#!/bin/bash
while [ 2 -gt 1 ]
do
echo yes
sleep 1
done




vim while3.sh
#!/bin/bash
while [ “abc” = “abc” ]
do
echo yes
sleep 1
done
4.3 if判断 
a. 单分支
if 测试条件
then
     选择分支
fi









vim if1.sh
#!/bin/bash
if [ $# -lt 1 ]
then
echo “not found param”
exit 100
fi

flag=$1
if [ $flag -eq 1 ]
then
echo “one”
fi
b. 双分支
if 测试条件
then
     选择分支1
else
选择分支2
fi


vim if2.sh
#!/bin/bash
if [ $# -lt 1 ]
then
echo “not found param”
exit 100
fi

flag=$1
if [ $flag -eq 1 ]
then
echo “one”
else
   echo “not support”
fi







c. 多分支
if 测试条件1
then 
选择分支1
elif 测试条件2
then      
选择分支2
…
else
选择分支n
fi











vim if3.sh
#!/bin/bash
if [ $# -lt 1 ]
then
echo “not found param”
exit 100
fi

flag=$1
if [ $flag -eq 1 ]
then
echo “one”
elif [ $flag -eq 2 ]
then 
   echo “two”
elif [ $flag -eq 3 ]
then 
   echo “three”
else
   echo “not support”
fi

4.4 case语句
case $var in
pattern1)
      commands
      ;;
pattern2)
      commands
      ;;
esac
vim case.sh
#!/bin/bash
case $1 in
jack)
      echo “hello jack”
      ;;
mike)
      echo “hello mike”
      ;;
*)
      echo “hello everyone”
      ;;
esac
4.5 until 语句
until command
do
commands
done
vim until.sh
#!/bin/bash
num=10
until (( num == 0 ))
do
echo “Number is $num”
(( num-- ))
done









4.6 break和continue语句
Vim break.sh
#!/bin/bash
if [ $# -lt 1 ]
then
echo “not found param”
break
fi

flag=$1
if [ $flag -eq 1 ]
then
echo “one”
continue
else
   echo “not support”
fi





5. Shell中的函数
5.1 函数的定义和使用
a. 第一种格式
name()
{
command1
…
}
test()
{
    echo “test function”
{
b. 第二种格式
格式:
function name
{
command1
…
}
function greeting
{
     echo “hello,zhangsan”
}
如何调用函数: 直接使用函数名调用  function_name
5.2 向函数传递参数
function name
{
echo “Hello $1”
echo “Hello $2”
{
function greeting
{
   echo “Hello $1”
}
greeting lisi
5.3 函数返回值
return: 只能返回1-255的整数
用来供其他地方调用获取状态,因此通常仅返回0或1,
0表示成功,1表示失败
echo: 可以返回任何字符串结果
通常用于返回数据,比如一个字符串值或列表值
5.4 局部变量和全局变量
全局变量: 不做特殊声明,Shell中变量都是全局变量
局部变量: 定义变量时,使用local关键字;函数内和外
若存在同名变量,则函数内部变量覆盖外部变量
5.5 函数库
a. 为什么要定义函数库
经常使用的重复代码封装成函数文件
一般不直接执行,而是由其他脚本调用
calculate.sh
#!/bin/bash
. /Users/bruce/workspace/测试文件/lib/bash_function
add 12 23
reduce 90 30
multiple 12 12
divide 12 2
lib/base_function
function add
{
     echo “`expr $1 + $2`”
}
function reduce
{
     echo “`expr $1 - $2`”
}
function multiple
{
    echo “`expr $1 \* $2`”
}
function divide
{
    echo “`expr $1 / $2`”
}
function sys_load
{
echo “Memory Info”
echo
free -m
echo
echo “Disk Usage”
echo
df -h
echo
}
b.经验之谈
库文件名的后缀是任意的,但一般使用.lib
库文件通常没有可执行选项
库文件无需和脚本在同级目录,只需要在脚本中引用时指定
第一行一般使用#!/bin/echo,输出警告信息,避免用户执行
6. Shell扩展
6.1 后台运行
nohup  xxx.sh  &
关闭后台运行程序或脚本:
ps -ef|grep xxx
kill PID
6.2 标准输出、标准错误输出、重定向
标准输出: 表示命令或程序输出的正常信息 1
标准错误输出: 表示命令或程序输出的错误信息 2
重定向: > 把输出信息重定向到文件中
ll 1> a.txt 重复执行文件内容无变化,>会覆盖之前的内容
>> 追加内容到文件中
nohup hello.sh >/dev/null 2>&1 &
/dev/null: Linux中的黑洞,任何数据扔进去都找不到了
2>$1 表示把标准错误输出重定向到标准输出中
6.3 Linux中的定时器crontab
a. crontab格式: * * * * * user-name command
*: 分钟(0-59)   *: 小时(0-23) 
*:一个月中的第几天(1-31) *:月份(1-12)
*:星期几(0-6,星期天为0) 
user-name:用户名  command:具体需要指定的命令
b.	启动crontab服务: 
systemctl status crond
systemctl start crond
c.	修改crontab配置文件
vim /etc/crontab
vim showTime.sh
#!/bin/bash
showTime=`date “+%Y-%m-%d %H:%M:%S”`
echo $showTime
vim /etc/crontab
* * * * * root sh  showTime.sh >> showTime.log
tail -f showTime.log 监控日志文件输出信息
三、Hadoop


